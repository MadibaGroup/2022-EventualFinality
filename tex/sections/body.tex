% !TEX root = ../main.tex
\section{Introductory Remarks}

\begin{itemize}
\item Optimistic rollups are being used
\item Problem: multi-day (\eg seven) window for withdrawal
\item Why is this a problem? Others are solving this problem (alternative bridges with a TTP). Some examples include: Speculators want to move fast, voting in a DAO (red tape), sell them on L1 or another L2, DApp access on L1 (trading if efficient on L2 but you need to do something on L1). 
\item Disadvantage relative to zk-rollups
\item Solution: scope to liquid tokens (ETH and ERC20), open problem: NFTs or other non-substitutable tokens. 
\item Solution: (1) tradeable exits; (2) market to trade; (3) guaranteed exit (buyer runs ArbOS validator); (4) prediction market solution to guarantee exits to non-validating entities (importantly includes smart contracts)
\item Testing: we implemented (1) and (3); for (2) and (4), use your favourite DeFi project.
\end{itemize}

 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Background} 

\begin{itemize}
\item L1 and its scalability issues
\item Rollups as a solution
\item ZK-Rollups vs Optimistic (positive not normative)
\item Bridge works: inbox (few sentences: every L2 tx is on L1, in calldata, sequenced FIFO, sequencer) -> deterministic output, outbox (assertion), eventual finality
\item Withdrawal problem: origins
\end{itemize}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Proposed Solution} 

\subsection{Design Landscape}

\begin{itemize}
\item Landscape: atomic swaps
\item Landscape: Change the bridge instead of using a third party contract (reason: too late once you withdrawal)
\end{itemize}

\subsection{Fast Bridge} 

\begin{itemize}
\item Allow trading of exits (atomic unit) -> track most recent owner (constant time) in outbox. Authorization (only current owner can transfer) -> on execute, check for current owner. 
\item Self-insurance (staking a fidelity bond) (you need liquidity) 
\item Prediction market: someone else will insure it
\end{itemize}

\subsection{Implementation} 

\begin{itemize}
\item Arbitrum's Nitro. Bridge: inbox, sequencer, outbox.
\item Implemented a market, following is the gas cost related to the market:
gasUsed for opening a market on an exit: 329,983
gasUsed for transferring the exit to the market:  86,701 (it was the first transfer so a bit more expensive that the 2nd, 3rd,.. see below)
Gas cost for submitting the Bid for when the Bid is greater than ask -> trade occurs and settles in one single submitBid tx:  105,287
Gas cost for execution is: 92,148
\item Modify outbox to allow tradeable exits
\item Modify the Nitro codebase (arbnode and validator) to shrink the fraud proof window from 7 days to 1 minute: (1) Modify the confirmPeriod variable in the arbnode/node.go file, (2) modify the MakeAssertionInterval variable validator/staker.go
\item To make the bridge prediction market friendly: 
Modify the outbox: (1) added a Mapping that maps the proposed arbitrum block number (also known as assertion and node) to the pending state. (2) added a function which accepts a proposed block number and adds it to the pending assertions mapping.
Modify the rollupcore: The validator acts through the RollupCore.sol contract when making an assertion by calling a createNewNode() function. We modifies this function so that every time a node is created by the validator it's also added to the outbox's pending assertions mapping (outbox.addToPendingAssertions(latestNodeCreated()))

\item L1 gas costs: new function (transferSpender) : 
First Transfer: 
1) Alice withdraws ETH from L2
2) She transfers her exit to Bob
transferSpender in this case costs : gasUsed : 85,945
Second Transfer: 
2) Now Bob transfer his exit to Carol
transferSpender in this case costs : gasUsed : 48,810
Third Transfer:
2) Now Carol transfer his exit to Nancy
transferSpender in this case costs : gasUsed : 48,798

 (difference of two mappings)

\item L1 gas costs: execute the exit: 91,418

\item Unit tests: say something
\item What happens when an assertion fails? (pro: ticket fails with assertion, better for prediction markets (betting on assertion which is a batch of exits); ticket passes even if assertion fails, sounds better (caveat: probably won't happen)
\item Challenges: SDK, where to change, unit test failed assertions (good assertion, bad assertion where withdrawal is ok, bad assertion where the withdrawal is problematic)
\item Expose assertion failures/successes to external contract (submit ID for assertion, get back status: pending, finalized, or discarded). Write down the SDK call. (what happens to a failed assertions???)
\end{itemize}


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Discussion}

\subsection{Where to Solve Problem? }
\begin{itemize}
\item Exit to a third party collateral contract, implements trading
\end{itemize}

\subsection{Withdrawal Format }
\begin{itemize}
\item Divisible exits
\item ERC20 / ERC721? -> allowances or not? 
\end{itemize}

\subsection{Non-Substitutable Withdrawals}

\begin{itemize}
\item Illiquid tokens 
\item NFTs (substitute for ETH -> support)
\item Messages (oracle updates, read calls, any L2-to-L1 message...) (still offer insurance)
\end{itemize}

\subsection{Assertion Failures}

\begin{itemize}
\item does exit go away with the assertion or not? Pros/cons
\end{itemize}

\subsection{Markets}

\begin{itemize}
\item Can't use an AMM 
\item Can't run out
\item Simple auction
\item Divisible exits
\item Exit pools
\end{itemize}



