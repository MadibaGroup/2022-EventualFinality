% !TEX root = ../main.tex



\section{Everything About L1/L2 ETH Bridging}\label{sec:bridge}
	%Describe how would bridging Ether work (~ 1page)
Standard bridges are Ethereum-based smart contracts that facilitate the process of transferring Ether (and other assets) between Ethereum and an off-chain system (\texttt{a.k.a} Layer 2). In Arbitrum, a bridge contains a group of Ethereum smart contracts that each acts as a record-keeper and allows users to \textit{deposit} and \textit{withdraw} Ether to/from the off-chain system without taking custody of their funds. Here we briefly describe Arbitrum's asynchronous messaging systems for bridging ETH.

\subsection{Transferring ETH from Ethereum to Arbitrum (\texttt{a.k.a} Deposits)}

To execute \textit{any} transaction on the Arbitrum chain, users need to put that transaction into the \textit{inbox} contract on Ethereum. This contract is part of the Arbitrum bridge and has the responsibility of recording the calldata of transactions it receives on the Ethereum blockchain, note that this data can be used for verification of correct execution of transactions. Just like any smart contract, Inbox has a set of functions, among which \texttt{depositEth} allows users to transfer ETH to Arbitrum chain. To transfer ETH into Arbitrum via \texttt{depositEth} function, users must specify (1) the amount of  ETH they are willing to bridge and (2) the amount of ETH to pay for the storage costs of storing their transaction calldata on Arbitrum (\texttt{a.k.a} base submission fee). Once called with this parameters, the bridge generates a “pre-packaged” transaction to be executed on the off-chain system. This transaction includes the caller address on Ethereum, the caller address on Arbitrum, 0 callvalue, and an empty calldata. The transaction will be stored on the Arbitrum storage, hence the base submission fee is deducted from the amount deposited and the remaining ETH value will be credited to the sender’s account.


%Arbitrum Team : A special message type Taylor-made for ETH deposits that handles them more cleanly will be exposed soon.

\subsection{Transferring ETH from Arbitrum to Ethereum (\texttt{a.k.a} Withdrawals)} \label{sec:withdraw}

As mentioned in Section~\ref{sec:bridge}, Arbitrum bridge allows users to transfer ETH from Ethereum without holding those ETH in escrow. Once bridged, these ETH can be transferred back to Ethereum by sending an Arbitrum transaction to the \textit{ArbSys}; Arbitrum pre-compiled contract that lives at the same address on every Arbitrum chain (\texttt{address(100)}) and provides system-level functionalities. Users can withdraw ETH back to Ethereum by calling a payable \texttt{withdrawEth} method and providing (1) their Arbitrum address from which ETH is being transferred and (2) the amount of ETH they are willing to transfer to Ethereum. Once called, \texttt{withdrawEth} publishes an Arbitrum transaction which will be \textbf{only} executed after the dispute window is over. Unlike Ethereum, Arbitrum transactions do not have instant finality \ie they can only be finalized on Ethereum after the so-called dispute period is expired. 

The challenge period allows Arbitrum to provide better security guarantees against censorship attacks and dispute wrong assertions coming from malicious validators, if any. Once the dispute period is over, the withdrawal transaction (together with all other outgoing messages) will be Merklized and entered in the \textit{Outbox} contract on Ethereum; a member of the bridge that manages the messages originating from Arbitrum chain (\eg withdrawals). Only if the dispute period is expired, users can execute their withdrawal transactions by calling a certain \textit{Outbox} method and providing their transaction ID


\section{Research Problem: Slow Withdrawals}
As mentioned in Section~\ref{sec:withdraw}, because Arbitrum execution happens optimistically, transactions can be considered final only after the dispute period (7 days) is over. This imposes a significant delay for any message originating from Arbitrum to Ethereum, especially withdrawal transactions. Funds will be only released from the off-chain system after the withdrawal transaction is valid on Ethereum. In this paper, we propose three solutions that allow users to sidestep the confirmation delay entirely when withdrawing assets from Arbitrum t o Ethereum. 



\section{Potential Designs and Solutions}
	Describe 3 solutions we have the slides for 

\section{Evaluation Framework}
	Come up with the evaluation framework to compare the designs provided in he previous section, this will (hopefully) help us to choose one out of 3 to implement

\section{Economics}
	How much would you pay for a tradable ticket? Knowing that they are weird assets (+ non-fungible)\par
 Carrying costs + fees + ..


\section{Implementation}

 We have to find a market to buy/sell these tradable claims; order-book? AMM? \par
 We need liquidity (note that they are non-fungible)



11:40
Dec 20




%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%\section{L1/L2 Token Bridging}
%Here we briefly explain how L1/L2 token transfers work in Arbitrum,
%
%\subsection{How Alice deposits her L1 tokens into L2}
%
%Alice first approves her TKNs to the bridge. The way it works under the hood is Alice basically approves tokens to the gateway that the router will use (each token is registered at specific gateway). 
%\textit{The Standard Gateway contract will ultimately be making the token transfer call; thus, that's the contract Alice needs to approve (bridge.approveToken handles this approval)}. Next, Alice deposits 100 tokens to L2 using the bridge. This will escrows funds in the Gateway contract on L1, and send a message to mint tokens on L2. If this is a first time deposit to L2, a standard Arb ERC20 contract will automatically be deployed.
%
%\subsection{How Alice withdraws her L2 tokens into L1}
%
%Alice initiates a withdraw transaction for 100 TKNs from L2 by calling the L2 token bridge. The L2 Bridge will call the L2 Gateway Router to initiate a withdrawal via the Standard ERC20 gateway. This burns 100 TKNs, and calls ArbSys (ArbSys.sendTxToL1). Alice will have to wait for the dispute period to be over so that the transaction's assertion gets confirmed. Only after that an OutboxEntry (containing Alice's withdrawal tx) gets added in L1 Outbox. At this point the escrowed funds will be transferred out of the bridge via the outbox contract (Outbox.executeTransaction(), which in turn calls the encoded L1ERC20Gateway.finalizeInboundTransfer message, releasing the user's tokens from the L1ERC20Gateway contract's escrow.)
%
%
%\section{Problem Statement and Research Goal}
%
%\paragraph{Problem statement.} The way optimistic roll-ups work forces users to wait at least 7 days for their L2/L1 token withdrawal transactions to be executed. 
%\paragraph{Goal.} Our goal is to come up with a design that provides \textbf{instant finality} for L2/L1 token withdrawals.
%
%\section{Landscape of Designs}
%Here we describe three proposed solutions to the problem described above. See the Table~\ref{tab:proscons} for pros and cons of each solution.
%
%\subsection{Solution 01}
%In this solution, everything happens on L1. 
%
%\begin{itemize}
%
%\item Alice initiates a withdraw transaction for 100 TKNs from L2 by calling the L2 token bridge. 
%\item The L2 Bridge will call the L2 Gateway Router to initiate a withdrawal via the Standard ERC20 gateway. This burns 100 TKNs, and calls ArbSys (ArbSys.sendTxToL1)
%\item ArbSys.sendTxToL1 will trigger a function on L1 Bridge \textblue{(how?)} to issue Alice a promissory note redeemable for 100 TKNs. Note that this PN is still an unvalidated assertion and can only be redeemed after the 7-day period is over.
%\item Alice sends an Ask order for the PN to our \textbf{L1 market} (we will think if it is an order-driven or batch auction later) where it gets matched with Bob's Bid (100 TKNs for PN). 
%\item Trade occurs and Alice receives 100 TKNs.  
%\item Once the dispute period is over, Bob can go to the outbox and redeem his PN for 100 TKNs (releases 100 TKNs to Bob from the L1ERC20Gateway contract's escrow.)
%
%\end{itemize}
%
%\subsection{Solution 02}
%
%Matching: L2 , Settlement : L1
%\begin{itemize}
%
%\item Alice initiates a withdraw transaction for 100 TKNs from L2 by calling the L2 token bridge. 
%\item The L2 Bridge will call the L2 Gateway Router to initiate a withdrawal via the Standard ERC20 gateway. This burns 100 TKNs, and calls ArbSys (ArbSys.sendTxToL1) 
%\item ArbSys.sendTxToL1 will trigger a function on L1 Bridge \textblue{(how?)} to issue Alice a promissory note redeemable for 100 TKNs. Note that this PN is still an unvalidated assertion and can only be redeemed after the 7-day period is over.
%\item Alice sends an Ask order for the PN to our \textbf{L2 market} (we will think if it is an order-driven or batch auction later) where it gets matched with Bob's Bid (100 TKNs for PN). Note that trades are not settled at this time. 
%\item Alice and Bob will have to meet on L1 and exchange the PN/TKNs to settle their trade. 
%\item Once the dispute period is over, Bob can go to the outbox and redeem his PN for 100 TKNs (releases 100 TKNs to Bob from the L1ERC20Gateway contract's escrow.)
%
%\end{itemize}
%
%
%\subsection{Solution 03}
%Matching: L2 , Settlement : L2
%\begin{itemize}
%
%\item Alice initiates a withdraw transaction for 100 TKNs from L2 by calling the L2 token bridge. 
%\item The L2 Bridge will call the L2 Gateway Router to initiate a withdrawal via the Standard ERC20 gateway. This burns 100 TKNs, and issues Alice a promissory note redeemable for 100 TKNs (instead of calling ArbSys.sendTxToL1).
%\item Alice sends an Ask order for the PN to our \textbf{L2 market} where it gets matched with Bob's Bid (100 TKNs for PN). 
%\item Trade occurs: Alice sends her PN to Bob instantly on L2 while Bob sends her 100 TKNs on L1 simultaneously.
%\item Now Alice has 100 TKNs on L1. Once the dispute period is over, Bob withdraw his PN from L2 and redeem it for 100 TKNs.
%
%\end{itemize}
%
%
%\input{tables/proscons.tex}
%
%
%
%
%
%
